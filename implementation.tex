\section{Implementation}
When the program starts, a user interface is provided that allows for controlling some parameters of the application. One of these is number of slaves, which does not have to match the number of actual network slaves, it's the number of networks to train at each step. So if you have only eight slaves and you enter sixteen, then each slave will train two neural networks at each iteration of the algorithm. Another parameter is the number of generations to train. As you increase this parameter the time to complete the algorithm increases linearly. One of the hopes of this project is that the neural networks will get progressively better during each iteration. Another parameter sets the amount iterations a slave should train a single network. This is a constant for all slaves so that each generated neural network has been given a fair chance at training it's weights. The remaning parameters put upper bounds on the neural network structures themselves. A maximum number of hidden layers parameter sets an upper bound of the number of hidden layers for a neural network. A maximum number of nodes per layer parameter sets an upper bound on the number of nodes for a hidden layer, the number of input and output nodes depends on the map of input vectors to outputs used during training and cannot be changed by the user. Tweaking the number of iterations to train a network, the number of nodes per layer and number of layers can have a substantial effect on the time it takes for the algorithm to complete. To get the output of each hidden layer and the output layer is on the order of N*M or the multiplication between the weight matrix between the previous layer and the current layer and the nodes in that layer. As the number of nodes increases, the time to complete the operation for a layer increases.

Although the concurrency features of Clojure are nice, they are limited in that they only provide support for shared memory concurrency on a single JVM.  The distributed architecture uses a publish/subscribe model that is facilitated via the Java Messaging Service or JMS library~\cite{jms}. The model is simple, there are two message queues, one for the single master node, and one for the entire set of slaves. 

The neural network structures that are generated and bred are all back propagation neural networks with at least one hidden layer. They are encoded as strings representing serialized maps in Clojure. The master and slave communicati


A single network will be generated by presenting the application with a training set, then a test data set that is disjoint from the training set will be used to test the accuracy of the network.  