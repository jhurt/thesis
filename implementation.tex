\section{Implementation}
When the program starts, a user interface is provided that allows for controlling some parameters of the application. One of these is number of slaves, which does not have to match the number of actual network slaves, it's the number of networks to train at each step. So if you have only 8 slaves and you enter 16, then each slave will train 2 networks at each iteration of the algorithm. Another parameter is the number of generations to train. As you increase this parameter the time to complete the algorithm increases linearly. One of the hopes of this project is that the NN's will get progressively better during each iteration. The remaning parameters put upper bounds on the NN structures themselves. A maximum number of hidden layers parameter and a maximum number of nodes per layer parameter are available for keeping the NN's from getting too large and taking too long to train.


Although the concurrency features of Clojure are nice, they are limited in that they only provide support for shared memory concurrency on a single JVM.  The distributed architecture uses a publish/subscribe model that is facilitated via the Java Messaging Service (JMS)  (TODO cite) library. The model is simple, there are 2 message queues, one for the single master node, and one for the entire set of slaves. 